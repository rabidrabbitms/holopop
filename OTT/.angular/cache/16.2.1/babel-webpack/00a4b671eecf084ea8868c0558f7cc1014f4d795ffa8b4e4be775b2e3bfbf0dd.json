{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/rabid/source/repos/Holopop/OTT/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { WebPlugin } from '@capacitor/core';\nclass DropShadow {\n  constructor(options = {}) {\n    this.opacity = options.opacity || 0;\n    this.radius = options.radius || 0;\n    this.color = hexToRgb(options.color || '#000000') || '#000000';\n    function hexToRgb(hex) {\n      let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n      hex = hex.replace(shorthandRegex, function (_m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : null;\n    }\n  }\n}\nclass FrameConfig {\n  constructor(options = {}) {\n    this.id = options.id;\n    this.stackPosition = options.stackPosition || 'back';\n    this.x = options.x || 0;\n    this.y = options.y || 0;\n    this.width = options.width || 'fill';\n    this.height = options.height || 'fill';\n    this.borderRadius = options.borderRadius || 0;\n    this.dropShadow = new DropShadow(options.dropShadow);\n  }\n}\nexport class VideoRecorderWeb extends WebPlugin {\n  constructor() {\n    super({\n      name: 'VideoRecorder',\n      platforms: ['web']\n    });\n    this.previewFrameConfigs = [];\n    this.currentFrameConfig = new FrameConfig({\n      id: 'default'\n    });\n  }\n  _initializeCameraView() {\n    this.videoElement = document.createElement('video');\n    this.videoElement.autoplay = true;\n    this.videoElement.hidden = true;\n    this.videoElement.style.cssText = `\n\t\t\tobject-fit: cover;\n\t\t\tpointer-events: none;\n\t\t\tposition: absolute;\n\t\t`;\n    document.body.appendChild(this.videoElement);\n    this._updateCameraView(this.currentFrameConfig);\n  }\n  _updateCameraView(config) {\n    this.videoElement.style.width = config.width === 'fill' ? '100vw' : `${config.width}px`;\n    this.videoElement.style.height = config.height === 'fill' ? '100vh' : `${config.height}px`;\n    this.videoElement.style.left = `${config.x}px`;\n    this.videoElement.style.top = `${config.y}px`;\n    this.videoElement.style.zIndex = config.stackPosition === 'back' ? '-1' : '99999';\n    this.videoElement.style.borderRadius = `${config.borderRadius}px`;\n    this.videoElement.style.boxShadow = `0 0 ${config.dropShadow.radius}px 0 rgba(${config.dropShadow.color}, ${config.dropShadow.opacity})`;\n  }\n  initialize(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      console.warn('VideoRecorder: Web implementation is currently for mock purposes only, recording is not available');\n      let previewFrames = options.previewFrames.length > 0 ? options.previewFrames : [{\n        id: 'default'\n      }];\n      _this.previewFrameConfigs = previewFrames.map(config => new FrameConfig(config));\n      _this.currentFrameConfig = _this.previewFrameConfigs[0];\n      _this._initializeCameraView();\n      if (options.autoShow !== false) {\n        _this.videoElement.hidden = false;\n      }\n      if (navigator.mediaDevices.getUserMedia) {\n        _this.stream = yield navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        _this.videoElement.srcObject = _this.stream;\n      }\n      return Promise.resolve();\n    })();\n  }\n  destroy() {\n    this.videoElement.remove();\n    this.previewFrameConfigs = [];\n    this.currentFrameConfig = undefined;\n    this.stream.getTracks().forEach(track => track.stop());\n    return Promise.resolve();\n  }\n  flipCamera() {\n    console.warn('VideoRecorder: No web mock available for flipCamera');\n    return Promise.resolve();\n  }\n  addPreviewFrameConfig(config) {\n    if (this.videoElement) {\n      if (!config.id) {\n        return Promise.reject('id required');\n      }\n      let newFrame = new FrameConfig(config);\n      if (this.previewFrameConfigs.map(config => config.id).indexOf(newFrame.id) === -1) {\n        this.previewFrameConfigs.push(newFrame);\n      } else {\n        this.editPreviewFrameConfig(config);\n      }\n    }\n    return Promise.resolve();\n  }\n  editPreviewFrameConfig(config) {\n    if (this.videoElement) {\n      if (!config.id) {\n        return Promise.reject('id required');\n      }\n      let updatedFrame = new FrameConfig(config);\n      let existingIndex = this.previewFrameConfigs.map(config => config.id).indexOf(updatedFrame.id);\n      if (existingIndex !== -1) {\n        this.previewFrameConfigs[existingIndex] = updatedFrame;\n      } else {\n        this.addPreviewFrameConfig(config);\n      }\n      if (this.currentFrameConfig.id == config.id) {\n        this.currentFrameConfig = updatedFrame;\n        this._updateCameraView(this.currentFrameConfig);\n      }\n    }\n    return Promise.resolve();\n  }\n  switchToPreviewFrame(options) {\n    if (this.videoElement) {\n      if (!options.id) {\n        return Promise.reject('id required');\n      }\n      let config = this.previewFrameConfigs.filter(config => config.id === options.id);\n      if (config.length > 0) {\n        this._updateCameraView(config[0]);\n      } else {\n        return Promise.reject('id not found');\n      }\n    }\n    return Promise.resolve();\n  }\n  showPreviewFrame() {\n    if (this.videoElement) {\n      this.videoElement.hidden = false;\n    }\n    return Promise.resolve();\n  }\n  hidePreviewFrame() {\n    if (this.videoElement) {\n      this.videoElement.hidden = true;\n    }\n    return Promise.resolve();\n  }\n  startRecording() {\n    console.warn('VideoRecorder: No web mock available for startRecording');\n    return Promise.resolve();\n  }\n  stopRecording() {\n    console.warn('VideoRecorder: No web mock available for stopRecording');\n    return Promise.resolve({\n      videoUrl: 'some/file/path'\n    });\n  }\n  getDuration() {\n    return Promise.resolve({\n      value: 0\n    });\n  }\n  addListener() {\n    console.warn('VideoRecorder: No web mock available for addListener');\n  }\n}\n//# sourceMappingURL=web.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}